import java.util.ArrayList;
import java.util.Arrays;

public class Permutation {
    private int n;
    private int k;
    private boolean allowEmptySpots;

    private long count;
    private int[] userCounts;
    private int[] pairing;
    private boolean done;

    /**
     * Initialize a permutation which will select pairings of users to slots. There should be at
     * most p pairings. No pairing should be used more than once. No user should be used more than
     * once.
     *
     * @param n Number of users.
     * @param k Number of slots available.
     */
    public Permutation(int n, int k, boolean allowEmptyPositions) {
        this.n = n;
        this.k = k;
        this.allowEmptySpots = allowEmptyPositions;

        this.count = 0;

        this.userCounts = new int[this.n];
        Arrays.fill(this.userCounts, 0);
        this.pairing = new int[this.k];

        if (allowEmptyPositions) {
            Arrays.fill(this.pairing, -1);
        } else {
            Arrays.fill(this.pairing, 0);
            this.userCounts[0] = this.pairing.length;
        }

        this.done = false;
    }

    public Permutation(int n, int k) {
        this(n, k, true);
    }

    /**
     * Return the next permutation as a Matching object, representing a solution to the Stable
     * Matching problem contained in data.
     *
     * @param data The Matching object containing the problem to solve.
     * @return The next candidate solution to the problem.
     */
    public Matching getNextMatching(Matching data) {
        int[] pairing = getNextPairing();
        if (pairing == null) {
            return null;
        }

        Matching matching = convertPairingToMatching(data, pairing);
        return matching;
    }

    /**
     * Return a Matching (StableMarriage candidate) constructed from the int[] generated by
     * getNextPairing().
     *
     * @param data    The Matching object containing the problem to solve.
     * @param pairing The candidate solution as generated by getNextPairing.
     * @return The Matching corresponding to the provided pairing.
     */
    private Matching convertPairingToMatching(Matching data, int[] pairing) {

        int m = data.getServerCount();
        int n = data.getUserCount();
        ArrayList<Integer> server_slots = data.getServerSlots();

        int pairing_index = 0;
        ArrayList<Integer> user_matching = new ArrayList<Integer>(0);
        for (int i = 0; i < n; i++) {
            user_matching.add(-1);
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < server_slots.get(i); j++) {
                if (pairing[pairing_index] != -1) {
                    user_matching.set(pairing[pairing_index], i);
                }

                if (pairing_index == pairing.length) {
                    break;
                }

                pairing_index++;
            }
        }

        return new Matching(data, user_matching);
    }

    /**
     * Select the next pairing in "ascending order." Each user can be assigned to at most one spot,
     * and each spot can be assigned to at most one user, and there are more users than there
     * are spots. Therefore, the the length of the returned array will be k, and each spot in the
     * array will contain the index of user which will fill that spot.
     *
     * <p>Values for the users range from 0 to n-1, so let the counting system be a base-n counting
     * system. Each spot in the array must contain an integer in [0,n-1) and when a position in the
     * array wraps around, the next highest position is incremented.
     *
     * <p>Keep track of the number of instances of a given user's number are present in the
     * pairing. A pairing is only valid if each user is paired with a position at most 1 time.
     */
    private int[] getNextPairing() {
        if (done) {
            return null;
        }

        count++;

        do {
            incrementPairing();
        } while (!isValidPairing());

        int[] nextPairing = new int[pairing.length];
        System.arraycopy(pairing, 0, nextPairing, 0, pairing.length);
        return nextPairing;
    }

    private boolean isValidPairing() {
        for (int x : userCounts) {
            if (x > 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Increment one position of the pairing and update arrays appropriately.
     *
     * @param index The index of the array to increment.
     */
    private void incrementPairing(int index) {
        if (index == 0) {
            count++;
        }

        if (index >= pairing.length) {
            done = true;
            return;
        }

        removeUser(pairing[index]);

        // update users in matching
        pairing[index]++;
        if (pairing[index] >= n) {
            if (allowEmptySpots) {
                pairing[index] = -1;
            } else {
                pairing[index] = 0;
            }

            incrementPairing(index + 1);
        }

        addUser(pairing[index]);
    }

    private void incrementPairing() {
        incrementPairing(0);
    }

    private void updateUser(int user, int update) {
        if (user == -1 || user >= n) {
            return;
        }

        userCounts[user] += update;
    }

    private void removeUser(int user) {
        updateUser(user, -1);
    }

    private void addUser(int user) {
        updateUser(user, 1);
    }
}
